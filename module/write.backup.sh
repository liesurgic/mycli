# set -e enables exit immediately on non-zero exit status
# set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/utils.sh"

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================
# br() {
#     nl=$'\n'
#     echo "$nl"
# }

write_content() {
    local content="$1"
    local file="$2"

    printf "%s" "$content" > "$file"
}

# more_content() {
#     local content=""
#     local function_name="hello"
#     content+=$(br)
#     content+="${hello}(){"
#     content+=$(br)
#     content+='    echo $1'
#     content+=$(br)
#     content+="}"
#     echo "$content"
# }

# some_function() {
#     local content=""
#     content+='$var, $(cmd), $((1+1))'
#     content+=$(br)
#     content+=$(more_content)
#     write_content_to_file "$content" "test.txt"
# }
# (No need to redefine read_json_value, read_json_values, read_config_list, etc. Use those from utils.sh/read-config.sh)

# =============================================================================
# TEMPLATE FUNCTIONS
# =============================================================================



# Generate individual command help function
write_command_help_function() {
    local filename="$1"
    local cmd_name="$2"
    local cmd_desc="$3"
    local cli_name="$4"
    
    cat >> "$filename" << EOF

${cmd_name}_help() {
    echo "$cmd_name - $cmd_desc"
    echo ""
    echo "Usage: $cli_name $cmd_name [options]"
    echo ""
EOF
}

# Generate flags section
write_flags_section() {
    local filename="$1"
    local flags="$2"
    
    if [ -n "$flags" ]; then
        echo "    echo \"Options:\"" >> "$filename"
        
        while IFS= read -r flag_b64; do
            if [ -n "$flag_b64" ]; then
                local flag_info=$(extract_flag_info "$flag_b64")
                local flag_name=$(echo "$flag_info" | cut -d'|' -f1)
                local flag_shorthand=$(echo "$flag_info" | cut -d'|' -f2)
                local flag_desc=$(echo "$flag_info" | cut -d'|' -f3)
                
                if [ -n "$flag_name" ]; then
                    echo "    echo \"$(format_flag_display "$flag_name" "$flag_shorthand")\"" >> "$filename"
                    echo "    echo \"      $flag_desc\"" >> "$filename"
                fi
            fi
        done <<< "$flags"
    fi
}

# Generate examples section
write_examples_section() {
    local filename="$1"
    local cmd_name="$2"
    local flags="$3"
    local cli_name="$4"
    
    echo "    echo \"\"" >> "$filename"
    echo "    echo \"Examples:\"" >> "$filename"
    echo "    echo \"  $cli_name $cmd_name\"" >> "$filename"
    
    # Show examples based on actual flags (limit to first 2 for readability)
    local example_count=0
    if [ -n "$flags" ]; then
        while IFS= read -r flag_b64 && [ $example_count -lt 2 ]; do
            if [ -n "$flag_b64" ]; then
                local flag_info=$(extract_flag_info "$flag_b64")
                local flag_name=$(echo "$flag_info" | cut -d'|' -f1)
                local flag_shorthand=$(echo "$flag_info" | cut -d'|' -f2)
                
                if [ -n "$flag_name" ]; then
                    echo "    echo \"  $cli_name $cmd_name $(format_flag_display "$flag_name" "$flag_shorthand")\"" >> "$filename"
                    ((example_count++))
                fi
            fi
        done <<< "$flags"
    fi
    
    echo "}" >> "$filename"
}

# =============================================================================
# FILE OPERATIONS
# =============================================================================

content_header() {
    local filename="$1"
    local content=""
    content+="#!/bin/bash\n"
    
    cat > "$filename" << 'EOF'
#!/bin/bash

# Help Menu Functions
# Generated by mycli 

EOF
}

content_footer() {
    local filename="$1"
    # Add any footer content if needed
    echo "# End of generated help menu functions" >> "$filename"
}

# =============================================================================
# MAIN PROCESSING FUNCTIONS
# =============================================================================

# =============================================================================
# WRITE help.sh FROM CONFIG .json
# =============================================================================
write_cli() {
    local json_config="$1"
    local filename="$2"
    local content=""

    ensure_jq_installed
    set_globals "$json_config"
    
    content+=$(content_header)
    content+=$(build_help "$json_config")
    content+=$(content_commands "$json_config")
    content+=$(content_dispatcher, "$json_config")
    content+=$(content_footer)
    write_content "$content" "$filename" 
    chmod +x "$filename"
    print_success "üìù $filename"
}
# Writes help.sh from config.json

main_help_content() {
    cat << EOF
# Main help menu - lists all available commands
help() {
    echo "$NAME"
    echo "$DESCRIPTION"
    echo ""
    echo "Usage: $ALIAS <command> [options]"
    "$1"
    echo ""
    echo "Commands:"
}

EOF
}

main_command_help_content() {
    json_file_path=$1

    jq -c '.commands[]' "$json_file_path" | while read -r command; do
        command_name=$(echo "$command" | jq -r '.name')
        command_description=$(echo "$command" | jq -r '.description')
        
        echo "$command" | jq -c '.flags[]' | while read -r flag; do
            flag_name=$(echo "$flag" | jq -r '.name')
            flag_short_hand=$(echo "$flag" | jq -r '.shorthand')
            flag_description=$(echo "$flag" | jq -r '.description')
            
            write_flag "$command_name" "$command_description" "$flag_name" "$flag_short_hand" "$flag_description"
        done
    done
}
 
build_help() {
    # local json_config="$1"
    local content=""
    local cmd_help_content = $(main_command_help_content)
    content+=$(main_help_content "$cmd_help_content")
    
    # local NAME=$(read_module_name "$json_config")
    # local ALIAS=$(read_module_alias "$json_config")
    # local DESCRIPTION=$(read_module_description "$json_config")
    local commands=$(read_commands "$json_config")
    
    if [ -z "$commands" ]; then
        print_warn "No commands found in config file"
        return 0
    fi
    
    cat >> "$filename" << EOF

# Main help menu - lists all available commands
help() {
    echo "$NAME"
    echo "$DESCRIPTION"
    echo ""
    echo "Usage: $ALIAS <command> [options]"
    echo ""
    echo "Commands:"
EOF

    jq -c '.commands[]' "$json_file_path" | while read -r command; do
        command_name=$(echo "$command" | jq -r '.name')
        command_description=$(echo "$command" | jq -r '.description')
        
        echo "$command" | jq -c '.flags[]' | while read -r flag; do
            flag_name=$(echo "$flag" | jq -r '.name')
            flag_short_hand=$(echo "$flag" | jq -r '.shorthand')
            flag_description=$(echo "$flag" | jq -r '.description')
            
            write_flag "$command_name" "$command_description" "$flag_name" "$flag_short_hand" "$flag_description"
        done
    done
    
    # # Add each command to the main help
    # while IFS= read -r command_b64; do
    #     if [ -n "$command_b64" ]; then
    #         local cmd_name=$(read_command_name "$command_b64")
    #         local cmd_desc=$(read_command_description "$command_b64")
            
    #         if [ -n "$cmd_name" ]; then
    #             echo "    echo \"  $cmd_name    $cmd_desc\"" >> "$filename"
    #         fi
    #     fi
    # done <<< "$commands"
    
    cat >> "$filename" << EOF
    echo ""
    echo "Run '$cli_name <command> help' for detailed help on a specific command."
    echo "Run '$cli_name <command>' to execute a command."
}
EOF
    
    # Process each command
    local command_index=0
    while IFS= read -r command_b64; do
        if [ -n "$command_b64" ]; then
            local cmd_name=$(read_command_name "$command_b64")
            local cmd_desc=$(read_command_description "$command_b64")
            
            if [ -n "$cmd_name" ]; then
                print_info "Writing help function: $cmd_name"
                
                local flags=$(read_command_flags "$json_config" "$command_index")
                
                write_command_help_function "$filename" "$cmd_name" "$cmd_desc" "$cli_name"
                write_flags_section "$filename" "$flags"
                write_examples_section "$filename" "$cmd_name" "$flags" "$cli_name"
            fi
            ((command_index++))
        fi
    done <<< "$commands"
}

# Format flag display for help output
format_flag_display() {
    local flag_name="$1"
    local flag_shorthand="$2"
    if [ -n "$flag_shorthand" ]; then
        echo "  -$flag_shorthand, --$flag_name"
    else
        echo "  --$flag_name"
    fi
}


# =============================================================================
# WRITE MAIN DISPATCHER SCRIPT
# =============================================================================

# Generate main dispatcher script with dynamic command routing
write_dispatcher() {
    local json_config="$1"
    local output_dir="$2"
    
    # Extract CLI metadata using read-config functions
    local cli_name=$(read_module_name "$json_config" "mycli")
    local cli_description=$(read_module_description "$json_config" "My CLI Tools")
    
    local filename="$output_dir/dispatcher.sh"
    
    print_info "Generating main dispatcher: $cli_name.sh"
    
    # Write the main dispatcher script
    cat > "$filename" << EOF
#!/bin/bash

# $cli_name CLI - Main Dispatcher
# Generated from $(basename "$json_config")
# $cli_description

set -e

# Get the directory where this script is located
SCRIPT_DIR="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)"

# Load utilities
source "\$SCRIPT_DIR/utils.sh"

# Load help functions
source "\$SCRIPT_DIR/help.sh"

# Load config
json_config="\$SCRIPT_DIR/$(basename "$json_config")"

# Set module name for help functions
MODULE_NAME="$cli_name"

# Parse command line
COMMAND="\$1"
shift

# Show help if no arguments provided
if [ \$# -eq 0 ] && [ -z "\$COMMAND" ]; then
    help
    exit 0
fi

# Route commands
case "\$COMMAND" in
EOF
    
    # Add each command to the case statement
    local commands=$(read_commands "$json_config")
    local command_index=0
    while IFS= read -r command_b64; do
        if [ -n "$command_b64" ]; then
            local cmd_name=$(read_command_name "$command_b64")
            
            if [ -n "$cmd_name" ]; then
                echo "    $cmd_name)" >> "$filename"
                echo "        ${cmd_name}_help \"\$@\"" >> "$filename"
                echo "        # TODO: Implement $cmd_name command logic" >> "$filename"
                echo "        echo \"Command '$cmd_name' not yet implemented\"" >> "$filename"
                echo "        exit 1" >> "$filename"
                echo "        ;;" >> "$filename"
            fi
        fi
    done <<< "$commands"
    
    # Add help and unknown command handling
    cat >> "$filename" << EOF
    help|--help|-h)
        if [ -n "\$1" ]; then
            # Show specific command help
            case "\$1" in
EOF
    
    # Add help for each command
    local help_command_index=0
    while IFS= read -r command_b64; do
        if [ -n "$command_b64" ]; then
            local cmd_name=$(read_command_name "$command_b64")
            
            if [ -n "$cmd_name" ]; then
                echo "                $cmd_name)" >> "$filename"
                echo "                    ${cmd_name}_help" >> "$filename"
                echo "                    ;;" >> "$filename"
            fi
        fi
    done <<< "$commands"
    
    cat >> "$filename" << EOF
                *)
                    echo "Unknown command: \$1"
                    echo "Run '$cli_name help' for available commands."
                    exit 1
                    ;;
            esac
        else
            # Show main help
            help
        fi
        ;;
    *)
        echo "Unknown command: \$COMMAND"
        echo "Run '$cli_name help' for available commands."
        exit 1
        ;;
esac
EOF
    
    chmod +x "$filename"
    print_success "üìù $cli_name.sh"
}

write_commands() {
    local json_config="$1"
    local output_dir="$2"
    local module_name="$3"
    local filename="$output_dir/commands.sh"
    
    print_info "Generating commands file: commands.sh"
    
    # Write file header
    cat > "$filename" << 'EOF'
#!/bin/bash

# Command implementations
# Generated from config.json

EOF
    
    # Get all command names
    local command_names=$(read_command_names "$json_config")
    
    # Generate function for each command
    while IFS= read -r cmd_name; do
        if [ -n "$cmd_name" ]; then
            print_info "Writing command function: $cmd_name"
            
            # Start the function
            echo "${cmd_name}() {" >> "$filename"
            
            # Get flag names for this command
            local flag_names=$(read_command_flag_names "$json_config" "$cmd_name")
            local flag_index=0
            
            # Add flag variables
            while IFS= read -r flag_name; do
                if [ -n "$flag_name" ]; then
                    echo "    local ${flag_name}=\"\$$((flag_index + 1))\"" >> "$filename"
                    ((flag_index++))
                fi
            done <<< "$flag_names"
            
            # Add placeholder implementation
            echo "    echo \"Command '$cmd_name' not yet implemented\"" >> "$filename"
            echo "    echo \"Available flags: $(echo "$flag_names" | tr '\n' ' ' | sed 's/ $//')\"" >> "$filename"
            echo "}" >> "$filename"
            echo "" >> "$filename"
        fi
    done <<< "$command_names"
    
    chmod +x "$filename"
    print_success "üìù ${filename}"
}



write_cli config.json .tmp/cli.sh
