# set -e enables exit immediately on non-zero exit status
# set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/utils.sh"
source "$SCRIPT_DIR/read-config.sh"

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

# (No need to redefine read_json_value, read_json_values, read_config_list, etc. Use those from utils.sh/read-config.sh)

# =============================================================================
# TEMPLATE FUNCTIONS
# =============================================================================

# Generate main help menu that lists all commands
write_main_help_menu() {
    local filename="$1"
    local commands="$2"
    local cli_name="$3"
    local cli_description="$4"
    
    print_info "Writing help function"
    
    cat >> "$filename" << EOF

# Main help menu - lists all available commands
help() {
    echo "$cli_name - $cli_description"
    echo ""
    echo "Usage: $cli_name <command> [options]"
    echo ""
    echo "Commands:"
EOF
    
    # Add each command to the main help
    while IFS= read -r command_b64; do
        if [ -n "$command_b64" ]; then
            local cmd_name=$(read_command_name "$command_b64")
            local cmd_desc=$(read_command_description "$command_b64")
            
            if [ -n "$cmd_name" ]; then
                echo "    echo \"  $cmd_name    $cmd_desc\"" >> "$filename"
            fi
        fi
    done <<< "$commands"
    
    cat >> "$filename" << EOF
    echo ""
    echo "Run '$cli_name <command> help' for detailed help on a specific command."
    echo "Run '$cli_name <command>' to execute a command."
}
EOF
}

# Generate individual command help function
write_command_help_function() {
    local filename="$1"
    local cmd_name="$2"
    local cmd_desc="$3"
    local cli_name="$4"
    
    cat >> "$filename" << EOF

${cmd_name}_help() {
    echo "$cmd_name - $cmd_desc"
    echo ""
    echo "Usage: $cli_name $cmd_name [options]"
    echo ""
EOF
}

# Generate flags section
write_flags_section() {
    local filename="$1"
    local flags="$2"
    
    if [ -n "$flags" ]; then
        echo "    echo \"Options:\"" >> "$filename"
        
        while IFS= read -r flag_b64; do
            if [ -n "$flag_b64" ]; then
                local flag_info=$(extract_flag_info "$flag_b64")
                local flag_name=$(echo "$flag_info" | cut -d'|' -f1)
                local flag_shorthand=$(echo "$flag_info" | cut -d'|' -f2)
                local flag_desc=$(echo "$flag_info" | cut -d'|' -f3)
                
                if [ -n "$flag_name" ]; then
                    echo "    echo \"$(format_flag_display "$flag_name" "$flag_shorthand")\"" >> "$filename"
                    echo "    echo \"      $flag_desc\"" >> "$filename"
                fi
            fi
        done <<< "$flags"
    fi
}

# Generate examples section
write_examples_section() {
    local filename="$1"
    local cmd_name="$2"
    local flags="$3"
    local cli_name="$4"
    
    echo "    echo \"\"" >> "$filename"
    echo "    echo \"Examples:\"" >> "$filename"
    echo "    echo \"  $cli_name $cmd_name\"" >> "$filename"
    
    # Show examples based on actual flags (limit to first 2 for readability)
    local example_count=0
    if [ -n "$flags" ]; then
        while IFS= read -r flag_b64 && [ $example_count -lt 2 ]; do
            if [ -n "$flag_b64" ]; then
                local flag_info=$(extract_flag_info "$flag_b64")
                local flag_name=$(echo "$flag_info" | cut -d'|' -f1)
                local flag_shorthand=$(echo "$flag_info" | cut -d'|' -f2)
                
                if [ -n "$flag_name" ]; then
                    echo "    echo \"  $cli_name $cmd_name $(format_flag_display "$flag_name" "$flag_shorthand")\"" >> "$filename"
                    ((example_count++))
                fi
            fi
        done <<< "$flags"
    fi
    
    echo "}" >> "$filename"
}

# =============================================================================
# FILE OPERATIONS
# =============================================================================

write_file_header() {
    local filename="$1"
    cat > "$filename" << 'EOF'
#!/bin/bash

# Help Menu Functions
# Generated by mycli 

EOF
}

write_file_footer() {
    local filename="$1"
    # Add any footer content if needed
    echo "# End of generated help menu functions" >> "$filename"
}

# =============================================================================
# MAIN PROCESSING FUNCTIONS
# =============================================================================

# Process all commands from config
write_commands_from_config() {
    local config_file="$1"
    local filename="$2"
    
    # Extract CLI metadata using read-config functions
    local cli_name=$(read_module_name "$config_file")
    local cli_description=$(read_module_description "$config_file")
    
    # Use defaults if not found in config
    if [ -z "$cli_name" ]; then
        cli_name="CLI Tool"
    fi
    if [ -z "$cli_description" ]; then
        cli_description="Available Commands"
    fi
    
    local commands=$(read_commands "$config_file")
    
    if [ -z "$commands" ]; then
        print_warn "No commands found in config file"
        return 0
    fi
    
    # Generate main help menu first
    write_main_help_menu "$filename" "$commands" "$cli_name" "$cli_description"
    
    # Process each command
    local command_index=0
    while IFS= read -r command_b64; do
        if [ -n "$command_b64" ]; then
            local cmd_name=$(read_command_name "$command_b64")
            local cmd_desc=$(read_command_description "$command_b64")
            
            if [ -n "$cmd_name" ]; then
                print_info "Writing help function: $cmd_name"
                
                local flags=$(read_command_flags "$config_file" "$command_index")
                
                write_command_help_function "$filename" "$cmd_name" "$cmd_desc" "$cli_name"
                write_flags_section "$filename" "$flags"
                write_examples_section "$filename" "$cmd_name" "$flags" "$cli_name"
            fi
            ((command_index++))
        fi
    done <<< "$commands"
}

# =============================================================================
# WRITE help.sh FROM CONFIG .json
# =============================================================================

# Writes help.sh from config.json
write_help() {
    local config_file="$1"
    local output_dir="$2"
    local filename="$output_dir/help.sh"
    
    ensure_jq_installed
    
    write_file_header "$filename"
    write_commands_from_config "$config_file" "$filename"
    write_file_footer "$filename"
    
    chmod +x "$filename"
    print_success "📝 help.sh"
}

# Format flag display for help output
format_flag_display() {
    local flag_name="$1"
    local flag_shorthand="$2"
    if [ -n "$flag_shorthand" ]; then
        echo "  -$flag_shorthand, --$flag_name"
    else
        echo "  --$flag_name"
    fi
}


# =============================================================================
# WRITE MAIN DISPATCHER SCRIPT
# =============================================================================

# Generate main dispatcher script with dynamic command routing
write_main_dispatcher() {
    local config_file="$1"
    local output_dir="$2"
    
    # Extract CLI metadata using read-config functions
    local cli_name=$(read_module_name "$config_file")
    local cli_description=$(read_module_description "$config_file")
    
    # Use defaults if not found in config
    if [ -z "$cli_name" ]; then
        cli_name="mycli"
    fi
    if [ -z "$cli_description" ]; then
        cli_description="CLI Tool"
    fi
    
    local filename="$output_dir/$cli_name.sh"
    
    print_info "Generating main dispatcher: $cli_name.sh"
    
    # Write the main dispatcher script
    cat > "$filename" << EOF
#!/bin/bash

# $cli_name CLI - Main Dispatcher
# Generated from $(basename "$config_file")
# $cli_description

set -e

# Get the directory where this script is located
SCRIPT_DIR="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)"

# Load utilities
source "\$SCRIPT_DIR/utils.sh"

# Load help functions
source "\$SCRIPT_DIR/help.sh"

# Load config
CONFIG_FILE="\$SCRIPT_DIR/$(basename "$config_file")"

# Set module name for help functions
MODULE_NAME="$cli_name"

# Parse command line
COMMAND="\$1"
shift

# Show help if no arguments provided
if [ \$# -eq 0 ] && [ -z "\$COMMAND" ]; then
    help
    exit 0
fi

# Route commands
case "\$COMMAND" in
EOF
    
    # Add each command to the case statement
    local commands=$(read_commands "$config_file")
    local command_index=0
    while IFS= read -r command_b64; do
        if [ -n "$command_b64" ]; then
            local cmd_name=$(read_command_name "$command_b64")
            
            if [ -n "$cmd_name" ]; then
                echo "    $cmd_name)" >> "$filename"
                echo "        ${cmd_name}_help \"\$@\"" >> "$filename"
                echo "        # TODO: Implement $cmd_name command logic" >> "$filename"
                echo "        echo \"Command '$cmd_name' not yet implemented\"" >> "$filename"
                echo "        exit 1" >> "$filename"
                echo "        ;;" >> "$filename"
            fi
        fi
    done <<< "$commands"
    
    # Add help and unknown command handling
    cat >> "$filename" << EOF
    help|--help|-h)
        if [ -n "\$1" ]; then
            # Show specific command help
            case "\$1" in
EOF
    
    # Add help for each command
    local help_command_index=0
    while IFS= read -r command_b64; do
        if [ -n "$command_b64" ]; then
            local cmd_name=$(read_command_name "$command_b64")
            
            if [ -n "$cmd_name" ]; then
                echo "                $cmd_name)" >> "$filename"
                echo "                    ${cmd_name}_help" >> "$filename"
                echo "                    ;;" >> "$filename"
            fi
        fi
    done <<< "$commands"
    
    cat >> "$filename" << EOF
                *)
                    echo "Unknown command: \$1"
                    echo "Run '$cli_name help' for available commands."
                    exit 1
                    ;;
            esac
        else
            # Show main help
            help
        fi
        ;;
    *)
        echo "Unknown command: \$COMMAND"
        echo "Run '$cli_name help' for available commands."
        exit 1
        ;;
esac
EOF
    
    chmod +x "$filename"
    print_success "Generated: $cli_name.sh"
}

write_commands() {
    local config_file="$1"
    local output_dir="$2"
    local module_name="$3"
    local filename="$output_dir/commands.sh"
    
    print_info "Generating commands file: commands.sh"
    
    # Write file header
    cat > "$filename" << 'EOF'
#!/bin/bash

# Command implementations
# Generated from config.json

EOF
    
    # Get all command names
    local command_names=$(read_command_names "$config_file")
    
    # Generate function for each command
    while IFS= read -r cmd_name; do
        if [ -n "$cmd_name" ]; then
            print_info "Writing command function: $cmd_name"
            
            # Start the function
            echo "${cmd_name}() {" >> "$filename"
            
            # Get flag names for this command
            local flag_names=$(read_command_flag_names "$config_file" "$cmd_name")
            local flag_index=0
            
            # Add flag variables
            while IFS= read -r flag_name; do
                if [ -n "$flag_name" ]; then
                    echo "    local ${flag_name}=\"\$$((flag_index + 1))\"" >> "$filename"
                    ((flag_index++))
                fi
            done <<< "$flag_names"
            
            # Add placeholder implementation
            echo "    echo \"Command '$cmd_name' not yet implemented\"" >> "$filename"
            echo "    echo \"Available flags: $(echo "$flag_names" | tr '\n' ' ' | sed 's/ $//')\"" >> "$filename"
            echo "}" >> "$filename"
            echo "" >> "$filename"
        fi
    done <<< "$command_names"
    
    chmod +x "$filename"
    print_success "Generated: commands.sh"
}


write_help ./cli.json .tmp
write_main_dispatcher ./cli.json .tmp
write_commands ./cli.json .tmp mycli
